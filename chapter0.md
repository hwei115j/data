## 第0章

### 作業系統介面

作業系統的工作是(1)將電腦的資源在多個程式間共用，並且給程式提供一系列比硬體本身更有用的服務。(2)管理並抽象底層硬體，舉例來說，一個文書處理軟體（比如 word）不用去關心自己使用的是何種硬碟。(3)多工硬體，使得多個程式可以(至少看起來是)同時運行的。(4)最後，給程式間提供一種受控的對話模式，使得程式之間可以共用資料、共同工作。

作業系統通過介面向使用者程式提供服務。設計一個好的介面實際上是很難的。一方面我們希望介面設計得簡單和精准，使其易於正確地實現；另一方面，我們可能忍不住想為應用提供一些更加複雜的功能。解決這種矛盾的辦法是讓介面的設計依賴於少量的*機制* （*mechanism*)，而通過這些機制的組合提供強大、通用的功能。

本書通過 xv6 作業系統來闡述作業系統的概念，它提供 Unix 作業系統中的基本介面（由 Ken Thompson 和 Dennis Ritchie 引入），同時模仿 Unix 的內部設計。Unix 裡機制結合良好的窄介面提供了令人吃驚的通用性。這樣的介面設計非常成功，使得包括 BSD，Linux，Mac OS X，Solaris （甚至 Microsoft Windows 在某種程度上）都有類似 Unix 的介面。理解 xv6 是理解這些作業系統的一個良好起點。

![figure0-1](../pic/f0-1.png)

如圖0-1所示，xv6 使用了傳統的**內核**概念 - 一個向其他運行中程式提供服務的特殊程式。每一個運行中程式（稱之為**進程**）都擁有包含指令、資料、棧的記憶體空間。指令實現了程式的運算，資料是用於運算過程的變數，棧管理了程式的程序呼叫。

進程通過**系統調用**使用內核服務。系統調用會進入內核，讓內核執行服務然後返回。所以進程總是在使用者空間和內核空間之間交替運行。

內核使用了 CPU 的硬體保護機制來保證使用者進程只能訪問自己的記憶體空間。內核擁有實現保護機制所需的硬體許可權(hardware privileges)，而使用者程式沒有這些許可權。當一個使用者程式進行一次系統調用時，硬體會提升特權級並且開始執行一些內核中預定義的功能。

內核提供的一系列系統調用就是使用者程式可見的作業系統介面，xv6 內核提供了 Unix 傳統系統調用的一部分，它們是：

|系統調用 | 描述|
|--------|-----|
|fork() | 創建進程|
|exit() | 結束當前進程|
|wait() | 等待子進程結束|
|kill(pid) | 結束 pid 所指進程|
|getpid()| 獲得當前進程 pid|
|sleep(n)| 睡眠 n 秒|
|exec(filename, *argv)| 載入並執行一個檔|
|sbrk(n)| 為進程記憶體空間增加 n 位元組|
|open(filename, flags)| 打開文件，flags 指定讀/寫模式|
|read(fd, buf, n)| 從檔中讀 n 個位元組到 buf|
|write(fd, buf, n)| 從 buf 中寫 n 個位元組到檔|
|close(fd)| 關閉打開的 fd|
|dup(fd)| 複製 fd|
|pipe( p)| 創建管道， 並把讀和寫的 fd 返回到p|
|chdir(dirname)| 改變目前的目錄|
|mkdir(dirname)| 創建新的目錄|
|mknod(name, major, minor)| 創建設備檔|
|fstat(fd)| 返回檔資訊|
|link(f1, f2)| 給 f1 創建一個新名字(f2)|
|unlink(filename)| 刪除檔|

這一章剩下的部分將說明 xv6 系統服務的概貌 —— 進程，記憶體，檔描述符，管道和檔案系統，為了描述他們，我們給出了代碼和一些討論。這些系統調用在 shell 上的應用闡述了他們的設計是多麼獨具匠心。

shell 是一個普通的程式，它接受使用者輸入的命令並且執行它們，它也是傳統 Unix 系統中最基本的使用者介面。shell 作為一個普通程式，而不是內核的一部分，充分說明了系統調用介面的強大：shell 並不是一個特別的使用者程式。這也意味著 shell 是很容易被替代的，實際上這導致了現代 Unix 系統有著各種各樣的 shell，每一個都有著自己的使用者介面和腳本特性。xv6 shell 本質上是一個 Unix Bourne shell 的簡單實現。它的實現在第 7850 行。

### 進程和記憶體

一個 xv6 進程由兩部分組成，一部分是使用者記憶體空間（指令，資料，棧），另一部分是僅對內核可見的進程狀態。xv6 提供了分時特性：它在可用 CPU 之間不斷切換，決定哪一個等待中的進程被執行。當一個進程不在執行時，xv6 保存它的 CPU 寄存器，當他們再次被執行時恢復這些寄存器的值。內核將每個進程和一個 **pid** (process identifier) 關聯起來。

一個進程可以通過系統調用 `fork` 來創建一個新的進程。`fork` 創建的新進程被稱為**子進程**，子進程的記憶體內容同創建它的進程（父進程）一樣。`fork` 函數在父進程、子進程中都返回（一次調用兩次返回）。對於父進程它返回子進程的 pid，對於子進程它返回 0。考慮下面這段代碼：

~~~ C
int pid;
pid = fork();
if(pid > 0){
    printf("parent: child=%d\n", pid);
    pid = wait();
    printf("child %d is done\n", pid);
} else if(pid == 0){
    printf("child: exiting\n");
    exit();
} else {
    printf("fork error\n");
}
~~~

系統調用 `exit` 會導致調用它的進程停止運行，並且釋放諸如記憶體和打開檔在內的資源。系統調用 `wait` 會返回一個當前進程已退出的子進程，如果沒有子進程退出，`wait` 會等候直到有一個子進程退出。在上面的例子中，下面的兩行輸出

~~~
parent: child=1234
child: exiting
~~~

可能以任意順序被列印，這種順序由父進程或子進程誰先結束 `printf` 決定。當子進程退出時，父進程的 `wait` 也就返回了，於是父進程列印：

~~~
parent: child 1234 is done
~~~

需要留意的是父子進程擁有不同的記憶體空間和寄存器，改變一個進程中的變數不會影響另一個進程。

系統調用 `exec` 將從某個*檔*（通常是可執行檔）裡讀取記憶體鏡像，並將其替換到調用它的進程的記憶體空間。這份檔必須符合特定的格式，規定檔的哪一部分是指令，哪一部分是資料，哪裡是指令的開始等等。xv6 使用 ELF 檔案格式，第2章將詳細介紹它。當`exec`執行成功後，它並不返回到原來的調用進程，而是從ELF頭中聲明的入口開始，執行從檔中載入的指令。`exec` 接受兩個參數：可執行檔名和一個字串參數陣列。舉例來說：

~~~ C
char *argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
~~~

這段代碼將調用程式替換為 `/bin/echo` 這個程式，這個程式的參數清單為`echo hello`。大部分的程式都忽略第一個參數，這個參數慣例上是程式的名字（此例是 echo）。

xv6 shell 用以上調用為使用者執行程式。shell 的主要結構很簡單，詳見 `main` 的代碼（8001）。主迴圈通過 `getcmd` 讀取命令列的輸入，然後它調用 `fork` 生成一個 shell 進程的副本。父 shell 調用 `wait`，而子進程執行使用者命令。舉例來說，用戶在命令列輸入“echo hello”，`getcmd` 會以 `echo hello` 為參數調用 `runcmd`（7906）, 由 `runcmd` 執行實際的命令。對於 `echo hello`, `runcmd` 將調用 `exec` 。如果 `exec` 成功被調用，子進程就會轉而去執行 `echo` 程式裡的指令。在某個時刻 `echo` 會調用 `exit`，這會使得其父進程從 `wait` 返回。你可能會疑惑為什麼 `fork` 和 `exec` 為什麼沒有被合併成一個調用，我們之後將會發現，將創建進程——載入程式分為兩個過程是一個非常機智的設計。

xv6 通常隱式地分配使用者的記憶體空間。`fork` 在子進程需要裝入父進程的記憶體拷貝時分配空間，`exec` 在需要裝入可執行檔時分配空間。一個進程在需要額外記憶體時可以通過調用 `sbrk(n)` 來增加 n 位元組的資料記憶體。 `sbrk` 返回新的記憶體的位址。

xv6 沒有用戶這個概念當然更沒有不同用戶間的保護隔離措施。按照 Unix 的術語來說，所有的 xv6 進程都以 root 使用者執行。

### I/O 和檔描述符

**檔描述符**是一個整數，它代表了一個進程可以讀寫的被內核管理的物件。進程可以通過多種方式獲得一個檔描述符，如打開檔、目錄、設備，或者創建一個管道（pipe），或者複製已經存在的檔描述符。簡單起見，我們常常把檔描述符指向的物件稱為“檔”。檔描述符的介面是對檔、管道、設備等的抽象，這種抽象使得它們看上去就是位元組流。

每個進程都有一張表，而 xv6 內核就以檔描述符作為這張表的索引，所以每個進程都有一個從0開始的檔描述符空間。按照慣例，進程從檔描述符0讀入（標準輸入），從檔描述符1輸出（標準輸出），從檔描述符2輸出錯誤（標準錯誤輸出）。我們會看到 shell 正是利用了這種慣例來實現 I/O 重定向。shell 保證在任何時候都有3個打開的檔描述符（8007），他們是控制台（console）的默認檔描述符。

系統調用 `read` 和 `write` 從檔描述符所指的檔中讀或者寫 n 個位元組。`read(fd, buf, n)` 從 `fd` 讀最多 n 個位元組（`fd` 可能沒有 n 個位元組），將它們拷貝到 `buf` 中，然後返回讀出的位元組數。每一個指向檔的檔描述符都和一個偏移關聯。`read` 從當前檔偏移處讀取資料，然後把偏移增加讀出位元組數。緊隨其後的 `read` 會從新的起點開始讀數據。當沒有資料可讀時，`read` 就會返回0，這就表示檔結束了。

`write(fd, buf, n)` 寫 `buf` 中的 n 個位元組到 `fd` 並且返回實際寫出的位元組數。如果返回值小於 n 那麼只可能是發生了錯誤。就像 `read` 一樣，`write` 也從當前檔的偏移處開始寫，在寫的過程中增加這個偏移。

下面這段程式（實際上就是 `cat` 的本質實現）將資料從標準輸入複製到標準輸出，如果遇到了錯誤，它會在標準錯誤輸出輸出一條資訊。

~~~ C
char buf[512];
int n;

for(;;){
	n = read(0, buf, sizeof buf);
	if(n == 0)
    	break;
    if(n < 0){
        fprintf(2, "read error\n");
		exit();
	}
    if(write(1, buf, n) != n){
    	fprintf(2, "write error\n");
        exit();
	}
}
~~~

這段代碼中值得一提的是 `cat` 並不知道它是從檔、控制台或者管道中讀取資料的。同樣地 `cat` 也不知道它是寫到檔、控制台或者別的什麼地方。檔描述符的使用和一些慣例（如0是標準輸入，1是標準輸出）使得我們可以輕鬆實現 `cat`。

系統調用 `close` 會釋放一個檔描述符，使得它未來可以被 `open`, `pipe`, `dup` 等調用重用。一個新分配的檔描述符永遠都是當前進程的最小的未被使用的檔描述符。

檔描述符和 `fork` 的交叉使用使得 I/O 重定向能夠輕易實現。`fork` 會複製父進程的檔描述符和記憶體，所以子進程和父進程的檔描述符一模一樣。`exec` 會替換調用它的進程的記憶體但是會保留它的檔描述符表。這種行為使得 shell 可以這樣實現重定向：`fork` 一個進程，重新打開指定檔的檔描述符，然後執行新的程式。下面是一個簡化版的 shell 執行 `cat<input.txt` 的代碼:

~~~ C
char *argv[2];
argv[0] = "cat";
### argv[1] = 0;
if(fork() == 0) {
	close(0);
	open("input.txt", O_RDONLY);
    exec("cat", argv);
}
~~~

子進程關閉檔描述符0後，我們可以保證`open` 會使用0作為新打開的檔 `input.txt`的檔描述符（因為0是 `open` 執行時的最小可用檔描述符）。之後 `cat` 就會在標準輸入指向 `input.txt` 的情況下運行。

xv6 的 shell 正是這樣實現 I/O 重定位的（7930）。在 shell 的代碼中，記得這時 `fork` 出了子進程，在子進程中 `runcmd` 會調用 `exec` 載入新的程式。現在你應該很清楚為何 `fork` 和 `exec` 是單獨的兩種系統調用了吧。這種區分使得 shell 可以在子進程執行指定程式之前對子進程進行修改。

雖然 `fork` 複製了檔描述符，但每一個檔當前的偏移仍然是在父子進程之間共用的，考慮下面這個例子：

~~~ C
if(fork() == 0) {
	write(1, "hello ", 6);
	exit();
} else {
	wait();
	write(1, "world\n", 6);
}
~~~

在這段代碼的結尾，綁定在檔描述符1上的檔有資料"hello world"，父進程的 `write` 會從子進程 `write` 結束的地方繼續寫 (因為 `wait` ,父進程只在子進程結束之後才運行 `write`)。這種行為有利於循序執行的 shell 命令的順序輸出，例如 `(echo hello; echo world)>output.txt`。

`dup` 複製一個已有的檔描述符，返回一個指向同一個輸入/輸出物件的新描述符。這兩個描述符共用一個檔偏移，正如被 `fork` 複製的檔描述符一樣。這裡有另一種列印 “hello world” 的辦法：

~~~ C
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
~~~

從同一個原初檔描述符通過一系列 `fork` 和 `dup` 調用產生的檔描述符都共用同一個檔偏移，而其他情況下產生的檔描述符就不是這樣了，即使他們打開的都是同一份檔。`dup` 允許 shell 像這樣實現命令：`ls existing-file non-exsiting-file > tmp1 2>&1`. `2>&1` 告訴 shell 給這條命令一個複製描述符1的描述符2。這樣 `existing-file` 的名字和 `non-exsiting-file` 的錯誤輸出都將出現在 `tmp1` 中。xv6 shell 並未實現標準錯誤輸出的重定向，但現在你知道該怎麼去實現它。

檔描述符是一個強大的抽象，因為他們將他們所連接的細節隱藏起來了：一個進程向描述符1寫出，它有可能是寫到一份檔，一個設備（如控制台），或一個管道。

### 管道

管道是一個小的內核緩衝區，它以檔描述符對的形式提供給進程，一個用於寫操作，一個用於讀操作。從管道的一端寫的資料可以從管道的另一端讀取。管道提供了一種進程間交互的方式。

接下來的示例代碼運行了程式 `wc`，它的標準輸出綁定到了一個管道的讀埠。

~~~ C
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0) {
	close(0);
	dup(p[0]);
	close(p[0]);
	close(p[1]);
	exec("/bin/wc", argv);
} else {
	write(p[1], "hello world\n", 12);
	close(p[0]);
	close(p[1]);
}
~~~

這段程式調用 `pipe`，創建一個新的管道並且將讀寫描述符記錄在陣列 `p` 中。在 `fork` 之後，父進程和子進程都有了指向管道的文件描述符。子進程將管道的讀埠拷貝在描述符0上，關閉 `p` 中的描述符，然後執行 `wc`。當 `wc` 從標準輸入讀取時，它實際上是從管道讀取的。父進程向管道的寫埠寫入然後關閉它的兩個文件描述符。

如果資料沒有準備好，那麼對管道執行的`read`會一直等待，直到有資料了或者其他綁定在這個管道寫埠的描述符都已經關閉了。在後一種情況中，`read` 會返回 0，就像是一份檔讀到了最後。讀操作會一直阻塞直到不可能再有新資料到來了，這就是為什麼我們在執行 `wc` 之前要關閉子進程的寫埠。如果 `wc` 指向了一個管道的寫埠，那麼 `wc` 就永遠看不到 eof 了。

xv6 shell 對管道的實現（比如 `fork sh.c | wc -l`）和上面的描述是類似的（7950行）。子進程創建一個管道連接管道的左右兩端。然後它為管道左右兩端都調用 `runcmd`，然後通過兩次 `wait` 等待左右兩端結束。管道右端可能也是一個帶有管道的指令，如 `a | b | c`, 它 `fork` 兩個新的子進程（一個 `b` 一個 `c`），因此，shell 可能創建出一顆進程樹。樹的葉子節點是命令，中間節點是進程，它們會等待左子和右子執行結束。理論上，你可以讓中間節點都運行在管道的左端，但做的如此精確會使得實現變得複雜。

pipe 可能看上去和暫存檔案沒有什麼兩樣：命令

`echo hello world | wc`

可以用無管道的方式實現：

`echo hello world > /tmp/xyz; wc < /tmp/xyz`

但管道和暫存檔案起碼有三個關鍵的不同點。首先，管道會進行自我清掃，如果是 shell 重定向的話，我們必須要在任務完成後刪除 `/tmp/xyz`。第二，管道可以傳輸任意長度的資料。第三，管道允許同步：兩個進程可以使用一對管道來進行二者之間的資訊傳遞，每一個讀操作都阻塞調用進程，直到另一個進程用 `write` 完成資料的發送。

### 檔案系統

xv6 檔案系統提供檔和目錄，檔就是一個簡單的位元組陣列，而目錄包含指向檔和其他目錄的引用。xv6 把目錄實現為一種特殊的檔。目錄是一棵樹，它的根節點是一個特殊的目錄 `root`。`/a/b/c` 指向一個在目錄 `b` 中的檔 `c`，而 b 本身又是在目錄 `a` 中的，`a` 又是處在 `root` 目錄下的。不從 `/` 開始的目錄表示的是相對調用進程目前的目錄的目錄，調用進程的目前的目錄可以通過 `chdir` 這個系統調用進行改變。下面的這些代碼都打開同一個檔（假設所有涉及到的目錄都是存在的）。

~~~ C
chdir("/a");
chdir("b");
open("c", O_RDONLY);

open("/a/b/c", O_RDONLY);
~~~

第一個程式碼片段將目前的目錄切換到 `/a/b`; 第二個代碼片段則對目前的目錄不做任何改變。

有很多的系統調用可以創建一個新的檔或者目錄：`mkdir` 創建一個新的目錄，`open` 加上 `O_CREATE` 標誌打開一個新的檔，`mknod` 創建一個新的設備檔。下面這個例子說明了這3種調用：

~~~ C
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONGLY);
close(fd);
mknod("/console", 1, 1);
~~~

`mknod` 在檔案系統中創建一個檔，但是這個檔沒有任何內容。相反，這個檔的元資訊標誌它是一個設備檔，並且記錄主設備號和輔設備號（`mknod` 的兩個參數），這兩個設備號唯一確定一個內核設備。當一個進程之後打開這個檔的時候，內核將讀、寫的系統調用轉發到內核設備的實現上，而不是傳遞給檔案系統。

`fstat` 可以獲取一個檔描述符指向的檔的資訊。它填充一個名為 `stat` 的結構體，它在 `stat.h` 中定義為：

~~~ C
#define T_DIR  1
#define T_FILE 2
#define T_DEV  3
// Directory
// File
// Device
     struct stat {
       short type;  // Type of file
       int dev;     // File system’s disk device
       uint ino;    // Inode number
       short nlink; // Number of links to file
       uint size;   // Size of file in bytes
};
~~~

檔案名和這個檔本身是有很大的區別。同一個檔（稱為 `inode`）可能有多個名字，稱為**連接** (`links`)。系統調用 `link` 創建另一個檔案系統的名稱，它指向同一個 `inode`。下面的代碼創建了一個既叫做 `a` 又叫做 `b` 的新檔。

~~~ C
open("a", O_CREATE|O_WRONGLY);
link("a", "b");
~~~

讀寫 `a` 就相當於讀寫 `b`。每一個 inode 都由一個唯一的 `inode 號` 直接確定。在上面這段代碼中，我們可以通過 `fstat` 知道 `a` 和 `b` 都指向同樣的內容：`a` 和 `b` 都會返回同樣的 inode 號（`ino`），並且 `nlink` 數會設置為2。

系統調用 `unlink` 從檔案系統移除一個檔案名。一個檔的 inode 和磁碟空間只有當它的連結數變為 0 的時候才會被清空，也就是沒有一個檔再指向它。因此在上面的代碼最後加上

`unlink("a")`，

我們同樣可以通過 `b` 訪問到它。另外，

~~~ C
fd = open("/tmp/xyz", O_CREATE|O_RDWR);
unlink("/tmp/xyz");
~~~

是創建一個臨時 inode 的最佳方式，這個 inode 會在進程關閉 `fd` 或者退出的時候被清空。

xv6 關於檔案系統的操作都被實現為使用者程式，諸如 `mkdir`，`ln`，`rm` 等等。這種設計允許任何人都可以通過用戶命令拓展 shell 。現在看起來這種設計是很顯然的，但是 Unix 時代的其他系統的設計都將這樣的命令內置在了 shell 中，而 shell 又是內置在內核中的。

有一個例外，那就是 `cd`，它是在 shell 中實現的（8016）。`cd` 必須改變 shell 自身的當前工作目錄。如果 `cd` 作為一個普通命令執行，那麼 shell 就會 `fork` 一個子進程，而子進程會運行 `cd`，`cd` 只會改變*子進程*的當前工作目錄。父進程的工作目錄保持原樣。

### 現實情況

UNIX 將“標準”的檔描述符，管道，和便於操作它們的 shell 命令整合在一起，這是編寫通用、可重用程式的重大進步。這個想法激發了 UNIX 強大和流行的“軟體工具”文化，而且 shell 也是首個所謂的“指令碼語言”。UNIX 的系統調用介面在今天仍然存在於許多作業系統中，諸如 BSD，Linux，以及 Mac OS X。

現代內核提供了比 xv6 要多得多的系統調用和內核服務。最重要的一點，現代基於 Unix 的作業系統並不遵循早期 Unix 將設備暴露為特殊檔的設計，比如剛才所說的控制台檔。Unix 的作者繼續打造Plan 9 專案，它將“資源是檔”的概念應用到現代設備上，將網路、圖形和其他資源都視作檔或者檔樹。

檔案系統抽象是一個強大的想法，它被以萬維網的形式廣泛的應用在互聯網資源上。即使如此，也存在著其他的作業系統介面的模型。Multics，一個 Unix 的前輩，將檔抽象為一種類似記憶體的概念，產生了十分不同的系統介面。Multics 的設計的複雜性對 Unix 的設計者們產生了直接的影響，他們因此想把檔案系統的設計做的更簡單。

這本書考察 xv6 是如何實現類似 Unix 的介面的，但涉及的想法和概念可以運用到 Unix 之外很多地方上。任何一個作業系統都需要讓多個進程複用硬體，實現進程之間的相互隔離，並提供處理序間通訊的機制。在學習 xv6 之後，你應該瞭解一些其他的更加複雜的作業系統，看一下他們當中蘊含的 xv6 的概念。

